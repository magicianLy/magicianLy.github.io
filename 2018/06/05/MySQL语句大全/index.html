<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>MySQL语句大全 | Magicianly</title>

  <!-- keywords -->
  

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="MySQL语句大全关系型数据库中数据完整性是什么1、实体完整性：每条记录都是独一无二的（主键/唯一约束/唯一索引） 2、参照完整性：表中的数据要参照其他的表已有的数据（外键） 3、域完整性：数据是有效的（数据类型/非空约束/默认值约束/检查约束）">
<meta name="keywords" content="MySQL">
<meta property="og:type" content="article">
<meta property="og:title" content="MySQL语句大全">
<meta property="og:url" content="http://yoursite.com/2018/06/05/MySQL语句大全/index.html">
<meta property="og:site_name" content="Magicianly">
<meta property="og:description" content="MySQL语句大全关系型数据库中数据完整性是什么1、实体完整性：每条记录都是独一无二的（主键/唯一约束/唯一索引） 2、参照完整性：表中的数据要参照其他的表已有的数据（外键） 3、域完整性：数据是有效的（数据类型/非空约束/默认值约束/检查约束）">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2018-08-15T12:13:22.538Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="MySQL语句大全">
<meta name="twitter:description" content="MySQL语句大全关系型数据库中数据完整性是什么1、实体完整性：每条记录都是独一无二的（主键/唯一约束/唯一索引） 2、参照完整性：表中的数据要参照其他的表已有的数据（外键） 3、域完整性：数据是有效的（数据类型/非空约束/默认值约束/检查约束）">
  
    <link rel="alternative" href="/atom.xml" title="Magicianly" type="application/atom+xml">
  
  
    <link rel="icon" href="https://i.imgur.com/sJIaT5C.jpg">
  
  <link rel="stylesheet" href="/css/style.css">
  
  

  <script src="//cdn.bootcss.com/require.js/2.3.2/require.min.js"></script>
  <script src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script>

  
      <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
<script>AV.initialize("OwMXlylMoU9wWk7rapIN5ghI-gzGzoHsz", "icxRJWTVsjH8y7aIqrp0iCIV");</script>
<script src="/js/Counter.js"></script>
  
</head>
<body>
  <div id="container">
    <div id="particles-js"></div>
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="http://www.qqzhi.com/uploadpic/2014-09-16/213245445.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">Magician</a></h1>
		</hgroup>

		
		<p class="header-subtitle">欢迎来到我的小屋</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						<li>友情链接</li>
						
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/Django/" style="font-size: 20px;">Django</a> <a href="/tags/HEXO-小知识总结/" style="font-size: 20px;">HEXO 小知识总结</a> <a href="/tags/Linux/" style="font-size: 10px;">Linux</a> <a href="/tags/MySQL/" style="font-size: 10px;">MySQL</a> <a href="/tags/git/" style="font-size: 10px;">git</a> <a href="/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/tags/程序人生/" style="font-size: 10px;">程序人生</a> <a href="/tags/随笔/" style="font-size: 10px;">随笔</a>
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://magicianly.github.io/">magicianly</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://violet-maple.github.io">波哥</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://blog.csdn.net/weixin_41782332">个人博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://zhouforrest.github.io/">超哥</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://jamey92.github.io/">jamey</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://karen2066.github.io/">Karen2066</a>
			        
			        </div>
				</section>
				

				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">Magician</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="http://www.qqzhi.com/uploadpic/2014-09-16/213245445.jpg" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">Magician</h1>
			</hgroup>
			
			<p class="header-subtitle">欢迎来到我的小屋</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap"><article id="post-MySQL语句大全" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/06/05/MySQL语句大全/" class="article-date">
  	<time datetime="2018-06-05T12:05:47.000Z" itemprop="datePublished">2018-06-05</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      MySQL语句大全
      
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySQL/">MySQL</a></li></ul>
	</div>

        

        
          
<div class="counter-tag counter">
    <span id="/2018/06/05/MySQL语句大全/" class="leancloud_visitors post-title-link"
          style="font-size: 12px" data-flag-title="MySQL语句大全">
         &nbsp;
        view
    </span>
</div>

        
        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>MySQL语句大全<br>关系型数据库中数据完整性是什么<br>1、实体完整性：每条记录都是独一无二的（主键/唯一约束/唯一索引）</p>
<p>2、参照完整性：表中的数据要参照其他的表已有的数据（外键）</p>
<p>3、域完整性：数据是有效的（数据类型/非空约束/默认值约束/检查约束）</p>
<a id="more"></a>
<p>表的设计原则：范式理论（1NF  /  2NF  /  3NF  /BCNF）</p>
<p>范式级别指的是表射击的规范程度，范式级别越高规范程度也就越高</p>
<p>范式级别越高在插入/删除/更新数据时可能发生的问题就越少</p>
<p>而且表中的数据冗余度（重复）也就越低</p>
<p>实际开发中旺旺会降低范式级别来提升查询数据的性能</p>
<p>1NF – 列的属性值不能够再拆分</p>
<p>2NF – 除了主键列之外的列要完全依赖于主键</p>
<p>场景：不同学院的学生可能有相同的学号<br>学生表(stuid, sname, ssex, did, dname, dtel)<br>主键(stuid，did)<br>sname和ssex依赖于stuid，而dname和dtel依赖于depid<br>这种依赖是部分依赖而不是完全依赖所以不满足2NF<br>3NF – 消除传递依赖<br>场景:整个学校学生的学号是唯一的<br>学生表(stuid, sname, ssex, did, dname, dtel)<br>主键（stuid）</p>
<p>1、说明：创建数据库<br><code>CREATE DATABASE database-name</code><br>2、说明：删除数据库<br><code>drop database dbname</code><br>3、说明：备份sql</p>
<h2 id="server"><a href="#server" class="headerlink" title="server"></a>server</h2><p>创建 备份数据的 device<br>USE<br>master<br>EXEC sp_addumpdevice<br>‘disk’,<br>‘testBack’,</p>
<h2 id="‘c-mssql7backup-MyNwind-1-dat’"><a href="#‘c-mssql7backup-MyNwind-1-dat’" class="headerlink" title="‘c:\mssql7backup\MyNwind_1.dat’"></a>‘c:\mssql7backup\MyNwind_1.dat’</h2><p>开始 备份<br>BACKUP<br>DATABASE pubs<br>4、说明：创建新表<br>create table tabname(col1<br>type1 [not null]<br>[primary key],col2<br>type2 [not null],..)<br>根据已有的表创建新表：<br>A：create table tab_new<br>like tab_old<br>(使用旧表创建新表)<br>B：create table tab_new<br>as select col1,col2…<br>from tab_old<br>definition only<br>5、说明：删除新表<br>drop table tabname<br>6、说明：增加一个列<br>Alter table tabname<br>add column col<br>type<br>注：列增加后将不能删除。DB2中列加上后数据类型也不能改变，唯一能改变的是增加varchar类型的长度。<br>7、说明：添加主键：<br>Alter table tabname<br>add primary key(col)<br>说明：删除主键：<br>Alter table tabname<br>drop primary key(col)<br>8、说明：创建索引：create [unique]<br>index idxname<br>on tabname(col….)<br>删除索引：drop index idxname<br>注：索引是不可更改的，想更改必须删除重新建。<br>9、说明：创建视图：create view viewname<br>as select statement<br>删除视图：drop view viewname<br>10、说明：几个简单的基本的sql语句<br>选择：select <em><br>from table1<br>where 范围<br>插入：insert into table1(field1,field2)<br>values(value1,value2)<br>删除：delete from table1<br>where 范围<br>更新：update table1<br>set field1=value1<br>where 范围<br>查找：select </em><br>from table1<br>where field1<br>like ’%value1%’<br>—like的语法很精妙，查资料!<br>排序：select <em><br>from table1<br>order by field1,field2<br>[desc]<br>总数：select count as totalcount<br>from table1<br>求和：select sum(field1)<br>as sumvalue<br>from table1<br>平均：select avg(field1)<br>as avgvalue<br>from table1<br>最大：select max(field1)<br>as maxvalue<br>from table1<br>最小：select min(field1)<br>as minvalue<br>from table1<br>11、说明：几个高级查询运算词<br>A：<br>UNION 运算符<br>UNION 运算符通过组合其他两个结果表(例如<br>TABLE1 和 TABLE2)并消去表中任何重复行而派生出一个结果表。当 ALL 随<br>UNION 一起使用时(即<br>UNION ALL)，不消除重复行。两种情况下，派生表的每一行不是来自<br>TABLE1 就是来自 TABLE2。<br>B：<br>EXCEPT 运算符<br>EXCEPT 运算符通过包括所有在<br>TABLE1 中但不在 TABLE2 中的行并消除所有重复行而派生出一个结果表。当 ALL 随<br>EXCEPT 一起使用时<br>(EXCEPT ALL)，不消除重复行。<br>C：<br>INTERSECT 运算符<br>INTERSECT 运算符通过只包括<br>TABLE1 和 TABLE2 中都有的行并消除所有重复行而派生出一个结果表。当 ALL 随<br>INTERSECT 一起使用时<br>(INTERSECT ALL)，不消除重复行。<br>注：使用运算词的几个查询结果行必须是一致的。<br>12、说明：使用外连接<br>A、left (outer)<br>join：<br>左外连接(左连接)：结果集既包括连接表的匹配行，也包括左连接表的所有行。<br>SQL:<br>select a.a,<br>a.b, a.c, b.c, b.d, b.f from a<br>LEFT OUT JOIN b<br>ON a.a<br>= b.c<br>B：right (outer)<br>join:<br>右外连接(右连接)：结果集既包括连接表的匹配连接行，也包括右连接表的所有行。<br>C：full/cross (outer)<br>join：<br>全外连接：不仅包括符号连接表的匹配行，还包括两个连接表中的所有记录。<br>12、分组:Group by:<br>组相关的信息：(统计信息)<br>count,sum,max,min,avg 分组的标准)<br>在selecte统计函数中的字段，不能和普通的字段放在一起;<br>13、对数据库进行操作：<br>分离数据库：<br>sp_detach_db; 附加数据库：sp_attach_db 后接表明，附加需要完整的路径名<br>14.如何修改数据库的名称:<br>sp_renamedb<br>‘old_name’,<br>‘new_name’<br>二、提升<br>1、说明：复制表(只复制结构,源表名：a<br>新表名：b) (Access可用)<br>法一：select </em><br>into b<br>from a<br>where 1&lt;&gt;1(仅用于SQlServer)<br>法二：select top 0</p>
<ul>
<li>into b<br>from a<br>2、说明：拷贝表(拷贝数据,源表名：a<br>目标表名：b) (Access可用)<br>insert into b(a,<br>b, c) select d,e,f<br>from b;<br>3、说明：跨数据库之间表的拷贝(具体数据使用绝对路径)<br>(Access可用)<br>insert into b(a,<br>b, c) select d,e,f<br>from b<br>in ‘具体数据库’<br>where 条件<br>例子：..from b<br>in ‘“&amp;Server.MapPath(“.”)&amp;”\data.mdb”<br>&amp;”‘ where..<br>4、说明：子查询(表名1：a<br>表名2：b)<br>select a,b,c<br>from a<br>where a<br>IN (select d<br>from b<br>) 或者: select a,b,c<br>from a<br>where a<br>IN (1,2,3)<br>5、说明：显示文章、提交人和最后回复时间<br>select a.title,a.username,b.adddate<br>from table a,(select max(adddate)<br>adddate from table where table.title=a.title)<br>b<br>6、说明：外连接查询(表名1：a<br>表名2：b)<br>select a.a,<br>a.b, a.c, b.c, b.d, b.f from a<br>LEFT OUT JOIN b<br>ON a.a<br>= b.c<br>7、说明：在线视图查询(表名1：a<br>)<br>select *<br>from (SELECT a,b,c<br>FROM a)<br>T where t.a<blockquote>
<p>1;<br>8、说明：between的用法,between限制查询数据范围时包括了边界值,not between不包括<br>select <em><br>from table1<br>where time between time1<br>and time2<br>select a,b,c,<br>from table1<br>where a<br>not between 数值1<br>and 数值2<br>9、说明：in 的使用方法<br>select </em><br>from table1<br>where a<br>[not]<br>in (‘值1’,’值2’,’值4’,’值6’)<br>10、说明：两张关联表，删除主表中已经在副表中没有的信息<br>delete from table1<br>where not exists<br>( select <em><br>from table2<br>where table1.field1=table2.field1<br>)<br>11、说明：四表联查问题：<br>select </em><br>from a<br>left inner join b<br>on a.a=b.b<br>right inner join c<br>on a.a=c.c<br>inner join d<br>on a.a=d.d<br>where …..<br>12、说明：日程安排提前五分钟提醒<br>SQL:<br>select <em><br>from 日程安排<br>where datediff(‘minute’,f开始时间,getdate())&gt;5<br>13、说明：一条sql<br>语句搞定数据库分页<br>b.</em> from (select top 20<br>主键字段,排序字段 from 表名<br>order by 排序字段<br>desc)<br>a,表名 b where b.主键字段<br>= a.主键字段 order by a.排序字段<br>具体实现：<br>关于数据库分页：<br>declare @start<br>int,@end int<br>@sql<br>nvarchar(600)<br>set @sql=’select top’+str(@end-@start+1)+’+from T<br>where rid<br>not in(select top’+str(@str-1)+’Rid<br>from T<br>where Rid&gt;-1)’<br>exec sp_executesql<br>@sql<br>注意：在top后不能直接跟一个变量，所以在实际应用中只有这样的进行特殊的处理。Rid为一个标识列，如果top后还有具体的字段，这样做是非常有好处的。因为这样可以避免<br>top的字段如果是逻辑索引的，查询的结果后实际表中的不一致(逻辑索引中的数据有可能和数据表中的不一致，而查询时如果处在索引则首先查询索引)<br>14、说明：前10条记录<br>select top 10</p>
</blockquote>
</li>
<li>form table1 where 范围<br>15、说明：选择在每一组b值相同的数据中对应的a最大的记录的所有信息(类似这样的用法可以用于论坛每月排行榜,每月热销产品分析,按科目成绩排名,等等.)<br>select a,b,c<br>from tablename<br>ta where a=(select max(a)<br>from tablename<br>tb where tb.b=ta.b)<br>16、说明：包括所有在<br>TableA 中但不在 TableB和TableC 中的行并消除所有重复行而派生出一个结果表<br>(select a<br>from tableA<br>) except (select a<br>from tableB)<br>except (select a<br>from tableC)<br>17、说明：随机取出10条数据<br>select top 10</li>
<li>from tablename<br>order by newid()<br>18、说明：随机选择记录<br>select newid()<br>19、说明：删除重复记录<br>1),delete from tablename<br>not in (select max(id)<br>from tablename<br>group by col1,col2,…)<br>2),select distinct <em><br>into temp from tablename<br>delete from tablename<br>insert into tablename<br>select </em><br>from temp<br>评价：<br>这种操作牵连大量的数据的移动，这种做法不适合大容量但数据操作<br>3),例如：在一个外部表中导入数据，由于某些原因第一次只导入了一部分，但很难判断具体位置，这样只有在下一次全部导入，这样也就产生好多重复的字段，怎样删除重复字段<br>alter table tablename<br>–添加一个自增列<br>add column_b<br>int identity(1,1)<br>delete from tablename<br>where column_b<br>not in(<br>select max(column_b)<br>from tablename<br>group by column1,column2,…)<br>alter table tablename<br>drop column column_b<br>20、说明：列出数据库里所有的表名<br>select name from sysobjects<br>where type=’U’ //<br>U代表用户<br>21、说明：列出表里的所有的列名<br>select name from syscolumns<br>where id=object_id(‘TableName’)<br>22、说明：列示type、vender、pcs字段，以type字段排列，case可以方便地实现多重选择，类似select 中的case。<br>select type,sum(case vender<br>when ‘A’ then pcs<br>else 0<br>end),sum(case vender<br>when ‘C’ then pcs<br>else 0<br>end),sum(case vender<br>when ‘B’ then pcs<br>else 0<br>end)<br>FROM tablename<br>group by type<br>显示结果：<br>type<br>vender pcs<br>电脑<br>电脑<br>A 1<br>光盘<br>B 2<br>光盘<br>A 2<br>手机<br>B 3<br>手机<br>C 3<br>23、说明：初始化表table1<br>TRUNCATE TABLE table1<br>24、说明：选择从10到15的记录<br>select top 5</li>
<li>from (select top 15</li>
<li>from table order by id<br>asc)<br>table_别名 order by id<br>desc<br>三、技巧<br>1、1=1，1=2的使用，在SQL语句组合时用的较多<br>“where 1=1”<br>是表示选择全部 “where 1=2”全部不选，<br>如：<br>if<br>@strWhere !=’’<br>begin<br>set @strSQL<br>= ‘select<br>count(<em>) as Total from [‘ +<br>@tblName + ‘]<br>where ‘ +<br>@strWhere<br>end<br>else<br>begin<br>set @strSQL<br>= ‘select<br>count(</em>) as Total from [‘ +<br>@tblName + ‘]’<br>end<br>我们可以直接写成<br>错误!未找到目录项。<br>set @strSQL<br>= ‘select<br>count(*) as Total from [‘ +<br>@tblName + ‘]<br>@strWhere 2、收缩数据库<br>–重建索引<br>DBCC<br>REINDEX<br>DBCC<br>INDEXDEFRAG<br>–收缩数据和日志<br>DBCC<br>SHRINKDB<br>DBCC<br>SHRINKFILE<br>3、压缩数据库<br>dbcc<br>shrinkdatabase(dbname)<br>4、转移数据库给新用户以已存在用户权限<br>‘update_one’,’newname’,’oldname’<br>go<br>5、检查备份集<br>RESTORE<br>VERIFYONLY from disk=’E:\dvbbs.bak’<br>6、修复数据库<br>ALTER DATABASE [dvbbs]<br>SET SINGLE_USER<br>GO<br>DBCC<br>CHECKDB(‘dvbbs’,repair_allow_data_loss)<br>WITH TABLOCK<br>GO<br>ALTER DATABASE [dvbbs]<br>SET MULTI_USER<br>GO<br>7、日志清除<br>SET NOCOUNT<br>ON<br>DECLARE @LogicalFileName<br>sysname,<br>@MaxMinutes<br>INT,<br>@NewSize<br>INT<br>USE<br>tablename –<br>要操作的数据库名<br>SELECT @LogicalFileName<br>= ‘tablename_log’,<br>日志文件名<br>@MaxMinutes<br>= 10, –<br>Limit on time allowed to wrap log.<br>@NewSize<br>= 1 –<br>你想设定的日志文件的大小(M)<br>/ initialize<br>DECLARE @OriginalSize<br>int<br>SELECT @OriginalSize<br>= size<br>FROM sysfiles<br>WHERE name =<br>@LogicalFileName<br>SELECT ‘Original<br>Size of ‘ +<br>db_name() + ‘<br>LOG is ‘ +<br>CONVERT(VARCHAR(30),@OriginalSize)</li>
</ul>
<ul>
<li>‘<br>CONVERT(VARCHAR(30),(@OriginalSize*8/1024))</li>
<li>‘MB’<br>FROM sysfiles<br>@LogicalFileName<br>CREATE TABLE DummyTrans<br>(DummyColumn<br>char (8000)<br>not null)<br>DECLARE @Counter<br>INT,<br>@StartTime<br>DATETIME,<br>@TruncLog<br>VARCHAR(255)<br>SELECT @StartTime<br>= GETDATE(),<br>@TruncLog<br>= ‘BACKUP<br>LOG ‘ +<br>db_name() + ‘<br>DBCC<br>SHRINKFILE (@LogicalFileName, @NewSize)<h2 id="EXEC-TruncLog"><a href="#EXEC-TruncLog" class="headerlink" title="EXEC (@TruncLog)"></a>EXEC (@TruncLog)</h2>Wrap the log if necessary.<br>WHILE<br>@MaxMinutes &gt; DATEDIFF (mi, @StartTime, GETDATE()) –<br>time has not expired<br>AND @OriginalSize<br>= (SELECT size FROM sysfiles<br>WHERE name =<br>AND (@OriginalSize</li>
</ul>
<ul>
<li>8 /1024) &gt; @NewSize<br>Outer loop.<br>SELECT @Counter<br>= 0<br>WHILE<br>((@Counter &lt; @OriginalSize / 16) AND (@Counter<br>&lt; 50000))<br>BEGIN –<br>update<br>INSERT DummyTrans<br>VALUES (‘Fill<br>Log’)<br>DELETE DummyTrans<br>SELECT @Counter<br>= @Counter + 1<br>END<br>EXEC (@TruncLog)<br>END<br>SELECT ‘Final<br>Size of ‘ +<br>db_name() + ‘<br>LOG is ‘ +<br>CONVERT(VARCHAR(30),size)</li>
</ul>
<ul>
<li>‘<br>8K pages or ‘ +<br>CONVERT(VARCHAR(30),(size*8/1024))</li>
<li>‘MB’<br>FROM sysfiles<br>WHERE name =<br>@LogicalFileName<br>DROP TABLE DummyTrans<br>SET NOCOUNT<br>OFF<br>8、说明：更改某个表<br>exec sp_changeobjectowner<br>‘tablename’,’dbo’<br>9、存储更改全部表<br>CREATE PROCEDURE dbo.User_ChangeObjectOwnerBatch<br>@OldOwner<br>as NVARCHAR(128),<br>@NewOwner<br>as NVARCHAR(128)<br>AS<br>DECLARE @Name as NVARCHAR(128)<br>DECLARE @Owner<br>as NVARCHAR(128)<br>DECLARE @OwnerName<br>as NVARCHAR(128)<br>DECLARE curObject<br>CURSOR FOR<br>select ‘Name’ =<br>name,<br>‘Owner’ =<br>user_name(uid)<br>from sysobjects<br>where user_name(uid)=@OldOwner<br>order by name<br>OPEN curObject<br>FETCH NEXT FROM curObject<br>INTO @Name,<br>@Owner<br>WHILE(@@FETCH_STATUS=0)<br>BEGIN<br>if<br>@Owner=@OldOwner<br>begin<br>set @OwnerName<br>= @OldOwner + ‘.’ +<br>rtrim(@Name)<br>exec sp_changeobjectowner<h2 id="OwnerName-NewOwner"><a href="#OwnerName-NewOwner" class="headerlink" title="@OwnerName, @NewOwner"></a>@OwnerName, @NewOwner</h2>select @name,@NewOwner,@OldOwner<br>FETCH NEXT FROM curObject<br>INTO @Name,<br>@Owner<br>END<br>close curObject<br>deallocate curObject<br>GO<br>10、SQL<br>SERVER中直接循环写入数据<br>declare @i<br>int<br>set @i=1<br>while<br>@i&lt;30<br>begin<br>insert into test<br>(userid) values(@i)<br>set @i=@i+1<br>end<br>案例：<br>有如下表，要求就裱中所有沒有及格的成績，在每次增長0.1的基礎上，使他們剛好及格:<br>Name score<br>Zhangshan<br>80<br>Lishi<br>59<br>Wangwu<br>50<br>Songquan<br>69<br>while((select min(score)<br>from tb_table)&lt;60)<br>begin<br>update tb_table<br>set score<br>=score<em>1.01<br>where score<60 if="" (select="" min(score)="" from="" tb_table)="">60<br>break<br>else<br>continue<br>end<br>1.按姓氏笔画排序:<br>Select </60></em><br>From TableName<br>Order By CustomerName<br>Collate Chinese_PRC_Stroke_ci_as<br>//从少到多<br>2.数据库加密:<br>select encrypt(‘原始密码’)<br>select pwdencrypt(‘原始密码’)<br>select pwdcompare(‘原始密码’,’加密后密码’)<br>= 1–相同;否则不相同<br>encrypt(‘原始密码’)<br>select pwdcompare(‘原始密码’,’加密后密码’)<br>= 1–相同;否则不相同<br>3.取回表中字段:<br>declare @list<br>varchar(1000),<br>@sql<br>nvarchar(1000)<br>select @list=@list+’,’+b.name from sysobjects<br>a,syscolumns b where a.id=b.id<br>and a.name=’表A’<br>set @sql=’select<br>‘+right(@list,len(@list)-1)+’<br>from 表A’<br>exec (@sql)<br>4.查看硬盘分区:<br>EXEC master..xp_fixeddrives<br>5.比较A,B表是否相等:<br>if<br>(select checksum_agg(binary_checksum(<em>))<br>from A)<br>=<br>(select checksum_agg(binary_checksum(</em>))<br>from B)<br>print<br>‘相等’<br>else<br>print<br>‘不相等’<br>6.杀掉所有的事件探察器进程:<br>DECLARE hcforeach<br>CURSOR GLOBAL FOR SELECT ‘kill<br>‘+RTRIM(spid)<br>FROM master.dbo.sysprocesses<br>WHERE program_name<br>IN(‘SQL<br>profiler’,N’SQL<br>事件探查器’)<br>EXEC sp_msforeach_worker<br>‘?’<br>7.记录搜索:<br>开头到N条记录<br>Select Top N</li>
</ul>
<ul>
<li>From 表<br>N到M条记录(要有主索引ID)<br>Select Top M-N</li>
<li>From 表<br>Where ID<br>in (Select Top M<br>ID From 表)<br>Order by ID<br>Desc</li>
</ul>
<hr>
<p>N到结尾记录<br>Select Top N</p>
<ul>
<li>From 表<br>Order by ID<br>Desc<br>案例<br>例如1：一张表有一万多条记录，表的第一个字段<br>RecID 是自增长字段， 写一个SQL语句，找出表的第31到第40个记录。<br>select top 10<br>recid from A<br>where recid<br>not in(select top 30<br>recid from A)<br>分析：如果这样写会产生某些问题，如果recid在表中存在逻辑索引。<br>select top 10<br>recid from A<br>where……是从索引中查找，而后面的select top 30<br>recid from A则在数据表中查找，这样由于索引中的顺序有可能和数据表中的不一致，这样就导致查询到的不是本来的欲得到的数据。<br>解决方案<br>1，<br>用order by select top 30<br>recid from A<br>order by ricid<br>如果该字段不是自增长，就会出现问题<br>2，<br>在那个子查询中也加条件：select top 30<br>recid from A<br>where recid&gt;-1<br>例2：查询表中的最后以条记录，并不知道这个表共有多少数据,以及表结构。<br>set @s<br>= ‘select<br>top 1 * from T where pid not in (select top ‘ +<br>str(@count-1)</li>
</ul>
<ul>
<li>‘<br>pid from T)’<br>print<br>@s exec sp_executesql<br>@s<br>9：获取当前数据库中的所有用户表<br>select Name from sysobjects<br>where xtype=’u’ and status&gt;=0<br>10：获取某一个表的所有字段<br>select name from syscolumns<br>where id=object_id(‘表名’)<br>select name from syscolumns<br>where id<br>in (select id<br>from sysobjects<br>where type<br>= ‘u’ and name =<br>‘表名’)<br>两种方式的效果相同<br>11：查看与某一个表相关的视图、存储过程、函数<br>select a.<em><br>from sysobjects<br>a, syscomments b where a.id<br>= b.id and b.text<br>like ‘%表名%’<br>12：查看当前数据库中所有存储过程<br>select name as 存储过程名称<br>from sysobjects<br>where xtype=’P’<br>13：查询用户创建的所有数据库<br>select </em><br>from master..sysdatabases<br>D where sid<br>not in(select sid<br>from master..syslogins<br>where name=’sa’)<br>或者<br>select dbid,<br>name AS DB_NAME<br>from master..sysdatabases<br>where sid<br>&lt;&gt; 0x01<br>14：查询某一个表的字段和数据类型<br>select column_name,data_type<br>from information_schema.columns<br>where table_name<br>= ‘表名’<br>15：不同服务器数据库之间的数据操作<br>–创建链接服务器<br>exec sp_addlinkedserver<br>‘ITSV<br>‘,<br>‘<br>‘,<br>‘,<br>‘远程服务器名或ip地址<br>‘<br>exec sp_addlinkedsrvlogin<br>‘ITSV<br>‘,<br>‘false<br>‘,null,<br>‘用户名<br>‘,<br>‘密码<br>‘<br>–查询示例<br>select <em><br>from ITSV.数据库名.dbo.表名<br>–导入示例<br>select </em><br>into 表<br>from ITSV.数据库名.dbo.表名<br>–以后不再使用时删除链接服务器<br>exec sp_dropserver<br>‘ITSV<br>‘,<br>‘droplogins<br>‘<br>–连接远程/局域网数据(openrowset/openquery/opendatasource)<br>–1、openrowset<br>–查询示例<br>select <em><br>from openrowset(<br>‘SQLOLEDB<br>‘,<br>‘sql服务器名<br>‘;<br>‘用户名<br>‘;<br>‘密码<br>‘,数据库名.dbo.表名)<br>–生成本地表<br>into 表<br>from openrowset(<br>‘SQLOLEDB<br>‘,<br>‘sql服务器名<br>‘;<br>‘用户名<br>‘;<br>‘密码<br>‘,数据库名.dbo.表名)<br>–把本地表导入远程表<br>insert openrowset(<br>‘SQLOLEDB<br>‘,<br>‘sql服务器名<br>‘;<br>‘用户名<br>‘;<br>‘密码<br>‘,数据库名.dbo.表名)<br>select </em>from 本地表<br>–更新本地表<br>update b<br>set b.列A=a.列A<br>from openrowset(<br>‘SQLOLEDB<br>‘,<br>‘sql服务器名<br>‘;<br>‘用户名<br>‘;<br>‘密码<br>‘,数据库名.dbo.表名)as a<br>inner join 本地表<br>b<br>on a.column1=b.column1<br>–openquery用法需要创建一个连接<br>–首先创建一个连接创建链接服务器<br>exec sp_addlinkedserver<br>‘,<br>‘<br>‘,<br>‘SQLOLEDB<br>‘,<br>‘远程服务器名或ip地址<br>‘<br>–查询<br>select *<br>FROM openquery(ITSV,<br>‘SELECT</li>
</ul>
<ul>
<li>FROM 数据库.dbo.表名 ‘)<br>insert openquery(ITSV,<br>‘SELECT</li>
<li>FROM 数据库.dbo.表名 ‘)<br>select *<br>from 本地表<br>–更新本地表<br>update b<br>set b.列B=a.列B<br>FROM openquery(ITSV,<br>‘SELECT</li>
<li>FROM 数据库.dbo.表名 ‘)<br>as a<br>inner join 本地表<br>b on a.列A=b.列A<br>–3、opendatasource/openrowset<br>SELECT <em><br>FROM opendatasource(<br>‘SQLOLEDB<br>‘,<br>‘Data<br>Source=ip/ServerName;User ID=登陆名;Password=密码 ‘ ).test.dbo.roy_ta<br>–把本地表导入远程表<br>insert opendatasource(<br>‘SQLOLEDB<br>‘,<br>‘Data<br>Source=ip/ServerName;User ID=登陆名;Password=密码 ‘).数据库.dbo.表名<br>select </em><br>from 本地表<br>SQL<br>Server基本函数<br>SQL<br>Server基本函数<br>1.字符串函数<br>长度与分析用<br>1,datalength(Char_expr)<br>2,substring(expression,start,length)<br>取子串，字符串的下标是从“1”，start为起始位置，length为字符串长度，实际应用中以len(expression)取得其长度<br>3,right(char_expr,int_expr)<br>返回字符串右边第int_expr个字符，还用left于之相反<br>4,isnull(<br>5,Sp_addtype<br>自定義數據類型<br>例如：EXEC sp_addtype<br>birthday, datetime, ‘NULL’<br>6,set nocount<br>{on|off}<br>使返回的结果中不包含有关受<br>Transact-SQL 语句影响的行数的信息。如果存储过程中包含的一些语句并不返回许多实际的数据，则该设置由于大量减少了网络流量，因此可显著提高性能。SET NOCOUNT<br>设置是在执行或运行时设置，而不是在分析时设置。<br>SET NOCOUNT<br>为 ON 时，不返回计数(表示受<br>SET NOCOUNT<br>为 OFF 时，返回计数<br>常识<br>在SQL查询中：from后最多可以跟多少张表或视图：256<br>在SQL语句中出现<br>Order by,查询时，先排序，后取<br>在SQL中，一个字段的最大容量是8000，而对于nvarchar(4000),由于nvarchar是Unicode码。<br>SQLServer2000同步复制技术实现步骤<br>一、<br>预备工作<br>1.发布服务器,订阅服务器都创建一个同名的windows用户,并设置相同的密码,做为发布快照文件夹的有效访问用户<br>–管理工具<br>–计算机管理<br>–用户和组<br>–右键用户<br>–新建用户<br>–建立一个隶属于administrator组的登陆windows的用户(SynUser)<br>我的电脑–D:\<br>新建一个目录,名为: PUB<br>–右键这个新建的目录<br>–属性–共享<br>–选择”共享该文件夹”<br>–通过”权限”按纽来设置具体的用户权限,保证第一步中创建的用户(SynUser)<br>具有对该文件夹的所有权限<br>–确定<br>3.设置SQL代理(SQLSERVERAGENT)服务的启动用户(发布/订阅服务器均做此设置)<br>开始–程序–管理工具–服务<br>–右键SQLSERVERAGENT<br>–属性–登陆–选择”此账户”<br>–输入或者选择第一步中创建的windows登录用户名(SynUser)<br>–”密码”中输入该用户的密码<br>4.设置SQL<br>Server身份验证模式,解决连接时的权限问题(发布/订阅服务器均做此设置)<br>企业管理器<br>–右键SQL实例–属性<br>–安全性–身份验证<br>–选择”SQL<br>Server 和 Windows”<br>–确定<br>5.在发布服务器和订阅服务器上互相注册<br>企业管理器<br>–右键SQL<br>Server组<br>–新建SQL<br>Server注册…<br>–下一步–可用的服务器中,输入你要注册的远程服务器名<br>–添加<br>–下一步–连接使用,选择第二个”SQL<br>Server身份验证”<br>–下一步–输入用户名和密码(SynUser)<br>–下一步–选择SQL<br>Server组,也可以创建一个新组<br>–下一步–完成<br>6.对于只能用IP,不能用计算机名的,为其注册服务器别名(此步在实施中没用到)<br>(在连接端配置,比如,在订阅服务器上配置的话,服务器名称中输入的是发布服务器的IP)<br>开始–程序–Microsoft<br>SQL Server–客户端网络实用工具<br>–别名–添加<br>–网络库选择”tcp/ip”–服务器别名输入SQL服务器名<br>–连接参数–服务器名称中输入SQL服务器ip地址<br>–如果你修改了SQL的端口,取消选择”动态决定端口”,并输入对应的端口号<br>二、<br>正式配置<br>1、配置发布服务器<br>打开企业管理器，在发布服务器(B、C、D)上执行以下步骤:<br>(1)<br>从[工具]下拉菜单的[复制]子菜单中选择[配置发布、订阅服务器和分发]出现配置发布和分发向导<br>(2)<br>[下一步] 选择分发服务器 可以选择把发布服务器自己作为分发服务器或者其他sql的服务器(选择自己)<br>(3)<br>[下一步] 设置快照文件夹<br>(4)<br>[下一步] 自定义配置<br>可以选择:是,让我设置分发数据库属性启用发布服务器或设置发布设置<br>否,使用下列默认设置(推荐)<br>(5)<br>[下一步] 设置分发数据库名称和位置 采用默认值<br>[下一步] 启用发布服务器 选择作为发布的服务器<br>[下一步] 选择需要发布的数据库和发布类型<br>(8)<br>[下一步] 选择注册订阅服务器<br>(9)<br>[下一步] 完成配置<br>2、创建出版物<br>发布服务器B、C、D上<br>(1)从[工具]菜单的[复制]子菜单中选择[创建和管理发布]命令<br>(2)选择要创建出版物的数据库，然后单击[创建发布]<br>(3)在[创建发布向导]的提示对话框中单击[下一步]系统就会弹出一个对话框。对话框上的内容是复制的三个类型。我们现在选第一个也就是默认的快照发布(其他两个大家可以去看看帮助)<br>SQLSERVER允许在不同的数据库如<br>orACLE或ACCESS之间进行数据复制。<br>但是在这里我们选择运行”SQL<br>SERVER 2000”的数据库服务器<br>注意:<br>如果前面选择了事务发布 则再这一步中只能选择带有主键的表<br>(6)选择发布名称和描述<br>(7)自定义发布属性<br>向导提供的选择:<br>是<br>我将自定义数据筛选,启用匿名订阅和或其他自定义属性<br>否<br>根据指定方式创建发布 (建议采用自定义的方式)<br>(8)[下一步]<br>选择筛选发布的方式<br>(9)[下一步]<br>可以选择是否允许匿名订阅<br>方法:<br>[工具]-&gt;[复制]-&gt;[配置发布、订阅服务器和分发的属性]-&gt;[订阅服务器] 中添加<br>否则在订阅服务器上请求订阅时会出现的提示:改发布不允许匿名订阅<br>如果仍然需要匿名订阅则用以下解决办法<br>[企业管理器]-&gt;[复制]-&gt;[发布内容]-&gt;[属性]-&gt;[订阅选项]<br>选择允许匿名请求订阅<br>2)如果选择匿名订阅,则配置订阅服务器时不会出现以上提示<br>(10)[下一步]<br>设置快照 代理程序调度<br>(11)[下一步]<br>完成配置<br>当完成出版物的创建后创建出版物的数据库也就变成了一个共享数据库<br>有数据<br>srv1.库名..author有字段:id,name,phone,<br>srv2.库名..author有字段:id,name,telphone,adress<br>要求：<br>srv1.库名..author增加记录则srv1.库名..author记录增加<br>srv1.库名..author的phone字段更新，则srv1.库名..author对应字段telphone更新<br>–<em>/<br>–大致的处理步骤<br>–1.在<br>srv1 上创建连接服务器,以便在 srv1 中操作 srv2,实现同步<br>exec sp_addlinkedserver<br>‘srv2’,’’,’SQLOLEDB’,’srv2的sql实例名或ip’<br>exec sp_addlinkedsrvlogin<br>‘srv2’,’false’,null,’用户名’,’密码’<br>go<br>–2.在<br>srv1 和 srv2 这两台电脑中,启动 msdtc(分布式事务处理服务),并且设置为自动启动<br>。我的电脑–控制面板–管理工具–服务–右键<br>Distributed Transaction Coordinator–属性–启动–并将启动类型设置为自动启动<br>go<br>–然后创建一个作业定时调用上面的同步处理存储过程就行了<br>企业管理器<br>–管理<br>–SQL<br>Server代理<br>–右键作业<br>–新建作业<br>–”常规”项中输入作业名称<br>–”步骤”项<br>–新建<br>–”步骤名”中输入步骤名<br>–”类型”中选择”Transact-SQL<br>脚本(TSQL)”<br>–”数据库”选择执行命令的数据库<br>–”命令”中输入要执行的语句:<br>exec p_process<br>–确定<br>–”调度”项<br>–新建调度<br>–”名称”中输入调度名称<br>–”调度类型”中选择你的作业执行安排<br>–如果选择”反复出现”<br>–点”更改”来设置你的时间安排<br>然后将SQL<br>Agent服务启动,并设置为自动启动,否则你的作业不会被执行<br>设置方法:<br>我的电脑–控制面板–管理工具–服务–右键<br>SQLSERVERAGENT–属性–启动类型–选择”自动启动”–确定.<br>–3.实现同步处理的方法2,定时同步<br>–在srv1中创建如下的同步处理存储过程<br>create proc<br>p_process<br>as<br>–更新修改过的数据<br>update b<br>set name=i.name,telphone=i.telphone<br>from srv2.库名.dbo.author<br>b,author i<br>where b.id=i.id<br>and<br>(b.name &lt;&gt;<br>i.name or b.telphone<br>&lt;&gt; i.telphone)<br>–插入新增的数据<br>insert srv2.库名.dbo.author(id,name,telphone)<br>select id,name,telphone<br>from author<br>i<br>where not exists(<br>select </em><br>from srv2.库名.dbo.author<br>where id=i.id)<br>–删除已经删除的数据(如果需要的话)<br>delete b<br>from srv2.库名.dbo.author<br>b<br>where not exists(<br>select *<br>from author<br>where id=b.id)<br>go<br>TO testBack<br>一张表，一旦分组完成后，查询后只能得到组相关的信息。<br>在SQLServer中分组时：不能以text,ntext,image类型的字段作为分组依据<br>select top 10<br>where id<br>A 1<br>where 1=1 安定 ‘+<h2 id="exec-sp-change-users-login"><a href="#exec-sp-change-users-login" class="headerlink" title="exec sp_change_users_login"></a>exec sp_change_users_login</h2>Setup<br>8K pages or ‘ +<br>WHERE name =<br>WITH TRUNCATE_ONLY’<br>@LogicalFileName)<br>BEGIN –<br>end<br>数据开发-经典<br>select pwdencrypt(‘原始密码’)</li>
</ul>
<hr>
<p>‘SQLOLEDB<br>select *<br>‘ITSV<br>–把本地表导入远程表<br>返回字符串包含字符数,但不包含后面的空格<br>check_expression , replacement_value )如果check_expression為空，則返回replacement_value的值，不為空，就返回check_expression字符操作类<br>Transact-SQL 语句影响的行数)。<br>2.在发布服务器上,新建一个共享目录,做为发布的快照文件的存放目录,操作:<br>采用默认\servername\Pub<br>(6)<br>(7)<br>(4)单击[下一步]系统要求指定可以订阅该发布的数据库服务器类型,<br>(5)单击[下一步]系统就弹出一个定义文章的对话框也就是选择要出版的表<br>1)如果选择署名订阅,则需要在发布服务器上添加订阅服务器</p>
<p>索引 - 用户查询的时候哪个字段用的多就在那里建索引<br>索引相当于一个目录，可以加速查询提升查询效率<br>索引是典型的用空间换时间的技术<br>索引会加速查询但是会让增、删、改变得更慢，因为增删改数据时索引也要更新<br>create index idx_emp_ename on tbemp (ename);<br>查看索引<br>show index from tbemp;<br>删除索引<br>drop index idx_emp_ename<br>通过视图可以将用户对表的查询权限，限制在某些列上，也就是说不同用户可以看到原始表的不同列的数据<br>函数和过程 - 封装重复操作<br>区别：函数可以产生返回值，而过程没有<br>函数和存储过程都是存储在数据库服务器端，编译好的代码，所以执行效率比直接向数据发出select 语句效率更高，如果希望简化调用，改善性能就可以使用<br>create or replace procedure sp_dept_avg_sal</p>
<p>MySQL查询优化<br>explain select … from … [where …]<br>explain select * from 表名 where name = ‘查询字段’;<br>Explain命令在解决数据库性能上是第一推荐使用命令，大部分的性能问题可以通过此命令来简单的解决，Explain可以用来查看SQL语句的执行效 果，可以帮助选择更好的索引和优化查询语句，写出更好的优化语句。</p>

      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2018/06/05/Django MTV模式详解/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">&lt;</strong>
      <div class="article-nav-title">
        
          Django的MTV模式
        
      </div>
    </a>
  
  
    <a href="/2018/05/29/hexo解决电脑更换无法写博客的问题/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">hexo解决电脑更换无法写博客的问题</div>
      <strong class="article-nav-caption">&gt;</strong>
    </a>
  
</nav>

  
</article>


<div class="ds-share share" data-thread-key="MySQL语句大全" data-title="MySQL语句大全" data-url="http://yoursite.com/2018/06/05/MySQL语句大全/"  data-images="http://www.qqzhi.com/uploadpic/2014-09-16/213245445.jpg" data-content="MySQL语句大全">
    <div class="ds-share-inline">
      <ul  class="ds-share-icons-16">
      	<li data-toggle="ds-share-icons-more"><a class="ds-more" href="javascript:void(0);">分享到：</a></li>
        <li><a class="ds-weibo" href="javascript:void(0);" data-service="weibo">微博</a></li>
        <li><a class="ds-qzone" href="javascript:void(0);" data-service="qzone">QQ空间</a></li>
        <li><a class="ds-qqt" href="javascript:void(0);" data-service="qqt">腾讯微博</a></li>
        <li><a class="ds-wechat" href="javascript:void(0);" data-service="wechat">微信</a></li>
      </ul>
      <div class="ds-share-icons-more">
      </div>
    </div>
 </div>
 





</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
      <div class="footer-left">
        &copy; 2018 Magician
      </div>
        <div class="footer-right">
          <a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/smackgg/hexo-theme-smackdown" target="_blank">Smackdown</a>
        </div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="/js/main.js"></script>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js"></script>


  </div>
</body>
</html>